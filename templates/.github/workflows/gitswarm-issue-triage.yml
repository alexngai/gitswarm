# GitSwarm Issue Triage â€” GitHub Actions Workflow
#
# Triggered when the gitswarm app dispatches an issue-enrichment event.
# Uses YOUR installed AI agent (Claude, Codex, or Copilot) for processing.
# The gitswarm app is the orchestrator; this workflow provides compute.
#
# Install: Copy to .github/workflows/ in your repo.
# Required: An AI coding agent installed on the repo (e.g. Claude for GitHub).

name: "GitSwarm: Issue Triage"

on:
  repository_dispatch:
    types: [gitswarm.plugin.issue-enrichment]

permissions:
  issues: write
  contents: read

jobs:
  triage:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Extract event data
        id: event
        run: |
          echo "issue_number=${{ github.event.client_payload.event.issue.number }}" >> "$GITHUB_OUTPUT"
          echo "issue_title=${{ github.event.client_payload.event.issue.title }}" >> "$GITHUB_OUTPUT"
          echo "plugin_name=${{ github.event.client_payload.gitswarm.plugin_name }}" >> "$GITHUB_OUTPUT"
          echo "execution_id=${{ github.event.client_payload.gitswarm.execution_id }}" >> "$GITHUB_OUTPUT"

      - name: Read context files
        id: context
        run: |
          # Read files specified in plugin config for AI context
          CONTEXT=""
          if [ -f "CONTRIBUTING.md" ]; then
            CONTEXT="$CONTEXT\n--- CONTRIBUTING.md ---\n$(head -100 CONTRIBUTING.md)"
          fi
          if [ -f ".gitswarm/config.yml" ]; then
            CONTEXT="$CONTEXT\n--- .gitswarm/config.yml ---\n$(cat .gitswarm/config.yml)"
          fi
          # Store truncated context
          echo "context<<CTXEOF" >> "$GITHUB_OUTPUT"
          echo "$CONTEXT" | head -200 >> "$GITHUB_OUTPUT"
          echo "CTXEOF" >> "$GITHUB_OUTPUT"

      - name: Build triage prompt
        id: prompt
        run: |
          cat > /tmp/triage-prompt.md << 'PROMPT_EOF'
          You are a repository triage assistant for a gitswarm-managed project.

          Analyze this new issue and provide:
          1. Suggested labels from the allowed set
          2. Complexity estimate (low/medium/high)
          3. Brief summary of the issue
          4. Any related issues or areas of the codebase

          Allowed labels: bug, feature, enhancement, documentation, good-first-issue, duplicate

          Respond in this JSON format:
          {
            "labels": ["label1", "label2"],
            "complexity": "low|medium|high",
            "summary": "brief summary",
            "related": "any related issues or code areas"
          }
          PROMPT_EOF

      - name: Triage with AI agent
        id: triage
        env:
          ISSUE_TITLE: ${{ github.event.client_payload.event.issue.title }}
          ISSUE_BODY: ${{ github.event.client_payload.event.issue.body }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # This step delegates to whichever AI agent is available.
          # Repos can customize this to use their preferred agent.
          #
          # Option A: Use GitHub Copilot CLI (if installed)
          # Option B: Use Claude API (if ANTHROPIC_API_KEY is set)
          # Option C: Use OpenAI API (if OPENAI_API_KEY is set)
          # Option D: Simple heuristic fallback
          #
          # For now, use heuristic fallback as the default.
          # Repos should replace this with their preferred AI agent.

          LABELS="[]"
          COMPLEXITY="medium"
          SUMMARY="New issue requires review"

          # Simple keyword-based classification
          TITLE_LOWER=$(echo "$ISSUE_TITLE" | tr '[:upper:]' '[:lower:]')

          if echo "$TITLE_LOWER" | grep -qE "bug|error|crash|fix|broken|fail"; then
            LABELS='["bug"]'
          elif echo "$TITLE_LOWER" | grep -qE "feature|add|new|request|proposal"; then
            LABELS='["feature"]'
          elif echo "$TITLE_LOWER" | grep -qE "doc|readme|guide|tutorial"; then
            LABELS='["documentation"]'
          elif echo "$TITLE_LOWER" | grep -qE "enhance|improve|update|refactor"; then
            LABELS='["enhancement"]'
          fi

          # Write results
          echo "labels=$LABELS" >> "$GITHUB_OUTPUT"
          echo "complexity=$COMPLEXITY" >> "$GITHUB_OUTPUT"
          echo "summary=$SUMMARY" >> "$GITHUB_OUTPUT"

      - name: Apply labels
        if: steps.triage.outputs.labels != '[]'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ steps.event.outputs.issue_number }}"
          LABELS='${{ steps.triage.outputs.labels }}'
          # Apply labels via GitHub CLI
          echo "$LABELS" | jq -r '.[]' | while read -r label; do
            gh issue edit "$ISSUE_NUM" --add-label "$label" 2>/dev/null || true
          done

      - name: Post triage comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ steps.event.outputs.issue_number }}"
          COMPLEXITY="${{ steps.triage.outputs.complexity }}"
          SUMMARY="${{ steps.triage.outputs.summary }}"

          COMMENT="### GitSwarm Issue Triage

          **Complexity:** ${COMPLEXITY}
          **Summary:** ${SUMMARY}

          ---
          *Triaged automatically by [GitSwarm](https://gitswarm.dev) plugin \`issue-enrichment\`*"

          gh issue comment "$ISSUE_NUM" --body "$COMMENT"

      - name: Report result to GitSwarm
        if: always()
        env:
          GITSWARM_API_KEY: ${{ secrets.GITSWARM_API_KEY }}
          GITSWARM_API_URL: ${{ secrets.GITSWARM_API_URL }}
        run: |
          # Report execution result back to gitswarm
          EXEC_ID="${{ steps.event.outputs.execution_id }}"
          REPO_ID="${{ github.event.client_payload.event.repository.id }}"
          STATUS="${{ job.status == 'success' && 'completed' || 'failed' }}"

          if [ -n "$GITSWARM_API_URL" ] && [ -n "$GITSWARM_API_KEY" ] && [ -n "$EXEC_ID" ]; then
            curl -s -X POST \
              "${GITSWARM_API_URL}/plugins/executions/${EXEC_ID}/report" \
              -H "Authorization: Bearer ${GITSWARM_API_KEY}" \
              -H "Content-Type: application/json" \
              -d "{\"status\": \"${STATUS}\", \"actions_taken\": [{\"action\": \"triage\", \"labels\": ${{ steps.triage.outputs.labels || '[]' }}}]}" \
              || true
          fi
