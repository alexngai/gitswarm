# Repo-Level Agent Federation

## Overview

GitSwarm currently makes federation decisions at the **contributor level** — agents register, earn karma, submit streams for review, and participate in consensus. The platform (web app or CLI) is the coordination authority.

This document proposes **repo-level agent federation**: a plugin/app architecture where repositories themselves define, install, and configure automated behaviors triggered by gitswarm events. This pushes decision-making closer to the repo, enables standalone operation without the gitswarm web app, and creates a composable ecosystem of repo automation plugins.

### Motivation

1. **Repos should own their automation.** A repo's merge policy, issue triage, and promotion rules are repo-level concerns. Centralizing them in the gitswarm server creates coupling and limits customization.

2. **GitHub-native integration.** Many teams already use GitHub Actions, branch protection, and webhooks. GitSwarm plugins should compose with these existing tools, not replace them.

3. **Standalone adoption path.** Teams should be able to install the GitSwarm GitHub App, drop a config file in their repo, and get multi-agent coordination without the gitswarm web app — similar to how Dependabot or Renovate work.

4. **Extensibility.** The agentbook project (github.com/arivero/agentbook) demonstrates that GitHub's native infrastructure (Issues, Labels, Actions, PRs) can serve as a complete agentic workflow orchestration layer. GitSwarm can standardize and productize these patterns.

---

## Prior Art: Agentbook

The [agentbook](https://github.com/arivero/agentbook) project implements several patterns relevant to this design:

### Labels as State Machine
Issue labels encode workflow state (`acknowledged` → `triaged-fast-track` → `assigned` → closed). Label transitions trigger subsequent workflow stages via GitHub Actions.

### Safe Outputs
Every agentic workflow declares strict limits on what it can mutate: maximum comments, allowed label set, maximum label additions, maximum issue closures. Agents are told "do not call GitHub write tools directly" — all mutations go through safe output handlers.

### Comment-Driven Handoffs
Phase handoffs use comment signatures (e.g., `"AI generated by [GH-AW Issue Research Pass]"`) as triggers for downstream dispatchers. This creates loosely-coupled chains where each phase's output triggers the next.

### Multi-Engine Fallback
Dispatchers check API token health and route to the first available AI engine (Codex → Claude → Copilot), providing resilience against service outages.

### PR Risk Gating
PRs are automatically risk-assessed based on changed paths (sensitive vs. safe), size limits, and file counts. Low-risk PRs are candidates for auto-approval.

### Competitive Agent Assignment
Multiple AI agents attempt the same task in parallel. Human maintainers choose which resulting PR to continue with.

---

## Design

### Three Tiers of Repo-Level Agency

#### Tier 1: Event-Driven Automation (Deterministic)

No AI required. Configurable rules that execute on gitswarm or GitHub events:

- Auto-label issues based on file paths or content patterns
- Auto-assign reviewers based on CODEOWNERS-style rules
- Auto-promote buffer → main when stabilization passes and all streams are merged
- Auto-close stale streams after N days of inactivity
- Notify external channels (Slack, Discord, webhooks) on specific events
- Enforce branch rules beyond what GitHub branch protection offers

#### Tier 2: AI-Augmented Processing (Agentic)

Workflows that use AI engines to process repo events:

- **Issue triage and enrichment**: Classify issues, add labels, estimate complexity, link related streams — modeled on agentbook's intake → routing → research pipeline
- **PR summarization and risk assessment**: Analyze changed files, identify risk areas, generate human-readable summaries
- **Automated code review**: Domain-specific review with repo context (coding standards, architectural patterns, dependency policies)
- **Dependency update analysis**: Evaluate dependency bumps for breaking changes, security implications
- **Documentation generation**: Generate or update docs from merged streams

#### Tier 3: Governance Delegation (Consensus → Action)

The most powerful tier — repo-level plugins that act on gitswarm governance decisions:

- **Consensus-gated merge**: When gitswarm community consensus is reached on a stream, the plugin merges the corresponding GitHub PR without gitswarm server involvement
- **Council proposal execution**: Council votes to add a maintainer, modify access, or promote — the plugin executes the decision at the GitHub level
- **Karma-gated auto-merge**: Agents above a karma threshold get auto-merge for changes to specific file patterns (e.g., docs, tests)
- **Cross-repo policy enforcement**: Org-wide plugins that enforce lint rules, security checks, or license compliance across all installed repos

---

### Plugin Architecture

#### Execution Models

Plugins can execute in three ways:

**Built-in (gitswarm server)**
```
gitswarm event → plugin engine (server-side) → GitHub API mutation
```
- Runs on gitswarm infrastructure
- Access to full gitswarm state (karma, consensus, council)
- Lowest latency for gitswarm-native operations

**GitHub Actions (repo-side)**
```
gitswarm event → repository_dispatch → GitHub Actions workflow → repo mutation
```
- Runs in the repo's own CI environment
- Full access to repo secrets and tooling
- Can use any GitHub Actions marketplace action
- Repo owner controls execution environment

**External Webhook (third-party)**
```
gitswarm event → HTTP POST to configured URL → external service → GitHub API mutation
```
- Enables integration with external services (CI/CD, monitoring, chat)
- Repo owner provides webhook URL and authentication
- GitSwarm verifies webhook delivery and logs results

#### Plugin Lifecycle

```
Install → Configure → Activate → Execute → Monitor → Update/Disable
```

1. **Install**: Select plugin from catalog or provide custom definition
2. **Configure**: Set trigger conditions, parameters, safe output limits
3. **Activate**: Plugin begins listening for events
4. **Execute**: Plugin runs when triggered, actions constrained by safe outputs
5. **Monitor**: All actions logged as gitswarm activity events, visible in dashboard
6. **Update/Disable**: Plugin config can be modified or disabled at any time

---

### The `.gitswarm/` Directory

Repos define their gitswarm configuration via a `.gitswarm/` directory:

```
.gitswarm/
├── config.yml              # Core settings (merge mode, consensus threshold, etc.)
├── plugins.yml             # Plugin installations and configuration
├── workflows/              # Custom workflow definitions (Tier 2/3)
│   ├── issue-triage.yml
│   ├── pr-gate.yml
│   └── auto-promote.yml
└── hooks/                  # Event hook handlers
    ├── on-stream-merged.yml
    ├── on-consensus-reached.yml
    └── on-stabilization-passed.yml
```

#### `config.yml` — Core Repository Settings

```yaml
# .gitswarm/config.yml
version: 1

# These mirror gitswarm_repos columns but are repo-owned
merge_mode: review              # swarm | review | gated
ownership_model: open           # solo | guild | open
consensus_threshold: 0.66
min_reviews: 2
human_review_weight: 1.5

buffer_branch: buffer
promote_target: main
auto_promote_on_green: true
auto_revert_on_red: true
stabilize_command: "npm test && npm run lint"

agent_access: karma_threshold
min_karma: 100

# Plugin-level kill switch
plugins_enabled: true
```

When the GitSwarm GitHub App detects changes to `.gitswarm/config.yml`, it syncs these settings to the gitswarm database. The repo-side config is the source of truth; the database is a cache for query performance.

#### `plugins.yml` — Plugin Configuration

```yaml
# .gitswarm/plugins.yml
version: 1

plugins:
  # Tier 1: Event-driven automation
  auto-promote:
    enabled: true
    trigger: gitswarm.stabilization_passed
    conditions:
      branch: buffer
      all_streams_merged: true
    actions:
      - promote_buffer_to_main
      - tag_release_semver_patch
      - close_completed_tasks
    safe_outputs:
      max_branch_updates: 1
      max_tags: 1
      max_issue_closures: 10

  stale-stream-cleanup:
    enabled: true
    trigger: schedule.daily
    conditions:
      stream_inactive_days: 14
    actions:
      - notify_stream_owner
      - abandon_after: 21  # days

  # Tier 2: AI-augmented processing
  issue-enrichment:
    enabled: true
    trigger: issues.opened
    engine: claude
    model: haiku                # cost-effective for triage
    context:
      - file: CONTRIBUTING.md
      - file: .gitswarm/config.yml
      - recent_issues: 20       # for dedup detection
    actions:
      - analyze_issue_context
      - add_labels
      - estimate_complexity
      - suggest_related_streams
      - link_duplicate_if_found
    safe_outputs:
      max_comments: 1
      allowed_labels:
        - bug
        - feature
        - enhancement
        - documentation
        - good-first-issue
        - duplicate
      max_label_additions: 3

  pr-risk-gate:
    enabled: true
    trigger: pull_request.opened
    engine: claude
    model: haiku
    risk_rules:
      blocked_paths:            # always require human review
        - ".github/workflows/"
        - ".gitswarm/"
        - "scripts/"
      safe_paths:               # candidates for auto-approve
        - "docs/"
        - "tests/"
        - "*.md"
      max_files_changed: 15
      max_lines_changed: 500
    actions:
      - assess_risk
      - add_risk_label          # low-risk | medium-risk | high-risk
      - post_summary_comment
      - auto_approve_if_low_risk
    safe_outputs:
      max_comments: 1
      allowed_labels: [low-risk, medium-risk, high-risk]
      max_approvals: 1          # only for low-risk

  # Tier 3: Governance delegation
  consensus-merge:
    enabled: true
    trigger: gitswarm.consensus_reached
    conditions:
      merge_mode: review
      consensus_threshold_met: true
      stabilization: green
    actions:
      - merge_stream_to_buffer
      - create_github_pr
      - notify_contributors
    safe_outputs:
      max_merges: 1
      max_prs: 1
      max_comments: 3

  karma-fast-track:
    enabled: true
    trigger: gitswarm.stream_submitted
    conditions:
      agent_karma: ">= 5000"
      files_match:
        - "docs/**"
        - "tests/**"
        - "*.md"
      max_files_changed: 5
      max_lines_changed: 200
    actions:
      - auto_approve_review
      - merge_to_buffer
    safe_outputs:
      max_approvals: 1
      max_merges: 1
```

---

### Event Bridge

The event bridge bidirectionally maps gitswarm and GitHub events:

```
GitSwarm Events                    GitHub Events
─────────────                      ─────────────
stream_created          ←→         branch created
commit                  ←→         push
submit_for_review       ←→         pull_request.opened
review_submitted        ←→         pull_request_review
consensus_reached        →         repository_dispatch
stream_merged           ←→         pull_request.merged
stabilization_passed     →         repository_dispatch
stabilization_failed     →         repository_dispatch
promote                  →         tag / release created
task_created            ←→         issue.opened
task_completed          ←→         issue.closed
council_proposal_passed  →         repository_dispatch
```

GitSwarm-only events (consensus_reached, stabilization_passed, council_proposal_passed) have no GitHub equivalent. These are dispatched to repos via GitHub's `repository_dispatch` API:

```javascript
// gitswarm server dispatches event to repo
await octokit.repos.createDispatchEvent({
  owner: 'acme-corp',
  repo: 'my-project',
  event_type: 'gitswarm.consensus_reached',
  client_payload: {
    stream_id: 'abc-123',
    stream_name: 'fix-auth-bug',
    consensus: {
      approvals: 5,
      rejections: 0,
      threshold: 0.66,
      achieved: 0.83
    },
    agent: {
      id: 'agent-456',
      name: 'CodeHelper',
      karma: 3200
    }
  }
});
```

Repos with GitHub Actions workflows listening for `repository_dispatch` events can then act on these:

```yaml
# .github/workflows/gitswarm-consensus-merge.yml
on:
  repository_dispatch:
    types: [gitswarm.consensus_reached]

jobs:
  merge:
    runs-on: ubuntu-latest
    steps:
      - name: Merge approved stream
        if: github.event.client_payload.consensus.achieved >= 0.66
        run: |
          gh pr merge "${{ github.event.client_payload.stream_name }}" --merge
```

---

### Standalone Mode

The most significant architectural implication: repos can use gitswarm functionality **without the gitswarm web app**.

#### Standalone Flow

1. **Install** the GitSwarm GitHub App on a repository
2. **Add** `.gitswarm/config.yml` with desired settings
3. **Add** `.gitswarm/plugins.yml` with desired plugins
4. **Push** — the GitHub App detects the config and activates

The GitHub App itself becomes a lightweight runtime:

```
GitHub webhook → GitSwarm GitHub App → Read .gitswarm/ config → Execute plugin → Mutate repo
```

#### What Standalone Mode Provides

- Multi-agent stream management (via git-cascade running in GitHub Actions or on the App's server)
- Consensus-based merging (votes tracked via PR reviews or issue comments)
- Automated issue triage and PR risk assessment
- Karma tracking (stored in `.gitswarm/state/karma.json` or a lightweight sidecar)
- Plugin execution for all three tiers

#### What Requires the Full GitSwarm Platform

- Cross-repo agent reputation (karma aggregated across repos)
- Global agent registry and discovery
- Dashboard and analytics
- Council governance with formal proposals
- Task marketplace and bounty system
- Real-time WebSocket event streaming

#### Graduation Path

```
Standalone (.gitswarm/ only)
    ↓ repo grows, needs cross-repo features
Connected (standalone + gitswarm server sync)
    ↓ org adopts gitswarm fully
Full Platform (gitswarm server as coordination authority)
```

---

### Plugin Catalog (Initial Set)

| Plugin | Tier | Trigger | Description |
|--------|------|---------|-------------|
| `auto-promote` | 1 | stabilization_passed | Promote buffer → main on green tests |
| `stale-cleanup` | 1 | schedule.daily | Warn and abandon inactive streams |
| `notify-slack` | 1 | configurable | Post to Slack on gitswarm events |
| `branch-guard` | 1 | push | Enforce branch rules beyond GitHub's built-in |
| `issue-triage` | 2 | issues.opened | AI-powered issue classification and enrichment |
| `pr-summarize` | 2 | pull_request.opened | AI-generated PR summary and risk assessment |
| `code-review` | 2 | pull_request.opened | Automated code review with repo context |
| `dep-check` | 2 | push | Analyze dependency changes for risk |
| `doc-gen` | 2 | stream_merged | Generate docs from merged code changes |
| `consensus-merge` | 3 | consensus_reached | Merge on community consensus |
| `karma-fast-track` | 3 | stream_submitted | Auto-merge for high-karma agents on safe paths |
| `council-execute` | 3 | council_proposal_passed | Execute council decisions at repo level |
| `cross-repo-policy` | 3 | configurable | Enforce org-wide policies |

---

### Safe Outputs: Capability Sandboxing

Every plugin must declare its maximum mutation budget. This is enforced by the plugin runtime (whether server-side or GitHub Actions):

```yaml
safe_outputs:
  # Content mutations
  max_comments: 2           # max issue/PR comments per execution
  max_label_additions: 3    # max labels added
  max_label_removals: 1     # max labels removed
  allowed_labels: [...]     # whitelist of labels plugin can use

  # Git mutations
  max_merges: 1             # max branch merges
  max_branch_creates: 1     # max new branches
  max_commits: 5            # max commits created
  max_files_changed: 20     # max files modified per commit

  # Issue/PR mutations
  max_issue_closures: 1     # max issues closed
  max_pr_creates: 1         # max PRs created
  max_approvals: 1          # max PR approvals

  # Release mutations
  max_tags: 1               # max tags created
  max_releases: 1           # max releases published

  # Rate limiting
  max_executions_per_hour: 10
  max_executions_per_day: 50
  cooldown_seconds: 60      # min time between executions
```

If a plugin attempts to exceed its budget, the action is blocked and an alert is logged.

---

### Security Model

#### Trust Levels for Plugins

```
built-in      → maintained by gitswarm core team, audited, trusted
community     → published in plugin catalog, reviewed, signed
custom        → defined in repo's .gitswarm/, repo owner's responsibility
external      → third-party webhook, sandboxed, limited capabilities
```

#### Escalation Policy

Plugins should escalate to humans when:
- Confidence is below a configurable threshold
- The action would affect protected branches
- The mutation budget would be exceeded
- The change crosses a risk threshold (e.g., touches security-sensitive files)

#### Audit Trail

All plugin actions are logged as gitswarm activity events:
```javascript
{
  type: 'plugin_execution',
  plugin: 'issue-triage',
  trigger: 'issues.opened',
  issue_number: 42,
  actions_taken: ['add_label:bug', 'add_label:high-priority', 'comment:triage_summary'],
  safe_output_usage: { comments: 1, labels: 2 },
  execution_time_ms: 3200,
  engine: 'claude:haiku',
  timestamp: '2026-02-09T...'
}
```

---

### Implementation Status

#### Phase 1: Foundation (IMPLEMENTED)

The initial implementation is in place:

**Database** (`src/db/migrations/003_repo_plugins.sql`):
- `gitswarm_repo_plugins` — plugin registrations per repo
- `gitswarm_plugin_executions` — audit trail of all executions
- `gitswarm_repo_config` — synced `.gitswarm/` config cache
- `gitswarm_plugin_rate_limits` — per-plugin rate limiting

**Services**:
- `src/services/plugin-engine.js` — Core orchestrator. Receives events, matches plugins, evaluates conditions, dispatches to GitHub Actions or executes built-in actions. Never runs AI itself.
- `src/services/safe-outputs.js` — Mutation budget enforcement. Tracks action consumption per execution, blocks over-budget actions.
- `src/services/config-sync.js` — Reads `.gitswarm/config.yml` and `.gitswarm/plugins.yml` from repos via GitHub API, syncs to database, reconciles plugin registrations.

**Routes** (`src/routes/gitswarm/plugins.js`):
- `GET /gitswarm/repos/:id/plugins` — List plugins
- `POST /gitswarm/repos/:id/plugins` — Install via API
- `PATCH /gitswarm/repos/:id/plugins/:name` — Update config
- `DELETE /gitswarm/repos/:id/plugins/:name` — Remove
- `POST /gitswarm/repos/:id/plugins/sync` — Sync from `.gitswarm/`
- `GET /gitswarm/repos/:id/plugins/executions` — Audit log
- `POST /gitswarm/repos/:id/plugins/executions/:id/report` — Callback from GitHub Actions

**Webhook Integration** (`src/routes/webhooks.js`):
- All webhook events are routed through the plugin engine after normal processing
- Push events that touch `.gitswarm/` files trigger automatic config sync

**Templates** (`templates/`):
- `.gitswarm/config.yml` — Repo configuration template
- `.gitswarm/plugins.yml` — Plugin configuration template with Tier 1-3 examples

#### Phase 2: gh-aw Integration (IMPLEMENTED)

Migrated from hand-written YAML workflow templates to [GitHub Agentic Workflows](https://github.com/github/gh-aw) (gh-aw) Markdown format. gh-aw compiles natural-language Markdown into GitHub Actions YAML, with built-in sandboxing, safe outputs, and multi-engine support.

**gh-aw Workflow Templates** (`templates/.github/workflows/*.md`):
- `gitswarm-issue-triage.md` — AI-powered issue classification, labeling, and duplicate detection
- `gitswarm-pr-risk.md` — PR risk assessment by path, size, and sensitivity
- `gitswarm-consensus-merge.md` — Merge PRs on gitswarm community consensus
- `gitswarm-daily-digest.md` — Scheduled daily activity summary
- `gitswarm-fix-pr.md` — Slash command `/fix` to auto-repair CI failures

**GitSwarm MCP Server** (`src/mcp-server/`):
- `@gitswarm/mcp-server` npm package exposing gitswarm data via Model Context Protocol
- Tools: `get_repo_config`, `get_consensus_status`, `get_agent_karma`, `list_active_streams`, `get_stream_status`, `search_issues`, `search_streams`, `get_repo_activity`, `get_stage_info`, `report_execution`
- gh-aw workflows declare `mcp-servers: gitswarm:` in frontmatter to access these tools
- Enables AI agents running inside workflows to query gitswarm state directly

**Plugin Engine `ghaw` Execution Model**:
- Config sync detects `gitswarm-*.md` files in `.github/workflows/` and registers them as plugins
- Native GitHub triggers (issues, PRs) fire directly — no dispatch from gitswarm server needed
- GitSwarm-only triggers (consensus, council) still dispatched via `repository_dispatch`
- Two-layer safe outputs: gh-aw enforces at the Actions level, gitswarm enforces at the server level

**Key advantages over Phase 1 YAML templates:**
- AI agent does the reasoning (not bash heuristics)
- Engine-portable: same Markdown prompt works with Claude, Copilot, or Codex
- gh-aw handles sandboxing, network isolation, and safe output enforcement
- MCP server gives workflows access to gitswarm data (consensus, karma, streams)
- Slash command support (`/fix`) not possible with pure repository_dispatch

#### Phase 3: Governance Delegation (NEXT)

- Council proposal auto-execution at repo level
- Karma-weighted auto-merge for safe paths
- Cross-repo policy enforcement
- Standalone mode (no gitswarm server required)
- `manual-approval:` gates for Tier 3 actions via gh-aw environment protection

#### Phase 4: Ecosystem

- Plugin catalog and marketplace
- Community plugin submissions and review process
- Plugin versioning and update mechanism
- Plugin composition (output of one plugin triggers another)
- Shared gh-aw workflow library (like githubnext/agentics)

---

### Open Questions

1. **Config source of truth**: When `.gitswarm/config.yml` and gitswarm database disagree, which wins? Proposed: repo-side config wins, database is cache. But what about settings only configurable via the web app?

2. **Karma in standalone mode**: Without the gitswarm server, where does karma live? The MCP server currently calls the gitswarm API, which requires a running server. Options for truly standalone: `repo-memory:` in gh-aw, GitHub Actions cache, or a lightweight sidecar.

3. **Plugin trust for Tier 3**: Governance delegation plugins can merge PRs and modify branches. gh-aw's `manual-approval:` gates (environment protection) provide a natural solution — Tier 3 workflows could require environment approval before executing. Should this be mandatory?

4. **Multi-repo coordination**: If an org has 50 repos all with gitswarm plugins, how do org-wide policies compose with repo-level configs? Proposed: org-level `.gitswarm/` in a dedicated config repo, with repo-level overrides.

5. **gh-aw adoption curve**: gh-aw is a research demonstrator, not a product. Should we maintain a fallback path (compiled YAML) for repos that can't or won't install the `gh` CLI extension? The `.lock.yml` files gh-aw generates are standard Actions YAML, so they could be committed directly.

6. **MCP server distribution**: The `@gitswarm/mcp-server` needs to be published to npm for `npx` to work in workflows. Until then, the server could be vendored as a GitHub Action or referenced via a git URL.

5. **Event ordering**: If multiple plugins trigger on the same event, what's the execution order? Proposed: priority field in plugin config, with built-in plugins executing before community/custom.

6. **Cost allocation**: AI-powered plugins (Tier 2) cost money. Who pays — the repo owner, the gitswarm platform, or the agent that triggered the event?
